<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Stateful Behaviour </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Stateful Behaviour ">
    
    
      <link rel="shortcut icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../styles/docfx.css">
      <link rel="stylesheet" href="../../styles/main.css">
      <meta property="docfx:navrel" content="../../toc.json">
      <meta property="docfx:tocrel" content="../toc.json">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>

                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../articles/guides.html" title="Manual">Manual</a>
                      </li>
                      <li>
                          <a href="../../api/index.html" title="Scripting API">Scripting API</a>
                      </li>
                      <li>
                          <a href="../../changelog/CHANGELOG.html" title="Changelog">Changelog</a>
                      </li>
                      <li>
                          <a href="../../license/LICENSE.html" title="License">License</a>
                      </li>
                </ul>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">

                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a href="../guides.html" title="Guides" class="">Guides</a>

                        <ul class="nav level2">
                          <li class="">
                            <a href="../guides/installation.html" title="Installation" class="">Installation</a>
                          </li>
                          <li class="">
                            <a href="../guides/getting_started.html" title="Getting Started" class="">Getting Started</a>
                          </li>
                          <li class="">
                            <a href="../guides/dependency_injection.html" title="Dependency Injection" class="">Dependency Injection</a>
                          </li>
                          <li class="">
                            <a href="../guides/loading.html" title="Loading" class="">Loading</a>
                          </li>
                          <li class="">
                            <a href="../guides/scene_changes.html" title="Scene Changes" class="">Scene Changes</a>
                          </li>
                          <li class="active">
                            <a href="../guides/stateful_behaviour.html" title="Stateful Behaviour" class="active">Stateful Behaviour</a>
                          </li>
                        </ul>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="stateful_behaviour">
<h1 id="stateful-behaviour">Stateful Behaviour</h1>

<p>In this section, we will explore an optional tool provided by <strong>AlchemyBow.Core</strong> that helps you manage the state of your app or game.</p>
<h2 id="introduction">Introduction</h2>
<p>Before we dive into the implementation, let’s introduce the concept of stateful behavior through a series of examples.</p>
<p>Imagine a simple PC game where the player can press the &quot;Escape&quot; button to toggle the pause menu.<br>
In this case, the game can exist in two states: the play state, where the player is actively playing, and the pause state, where the player is interacting with the menu.<br>
It's clear that there are relationships between these states: the game can transition from play to pause, and vice versa, but only when the player clicks the &quot;Escape&quot; button.<br>
From this, we can identify three key elements: states, transitions that connect them, and conditions that trigger the transitions.
<img src="../../images/States1.png" alt="Play State and Pause State"></p>
<p>For the next part, let’s make two assumptions about the imaginary game:</p>
<ul>
<li>States are used to toggle game modules, for example, enabling or disabling the player avatar.</li>
<li>The pause menu doesn’t cover the entire screen—the remaining elements are slightly dimmed.</li>
</ul>
<p>With these assumptions in mind, we can identify a new problem. Since the player avatar is visible in both the play and pause states, any transition between these states would cause the avatar module to toggle unnecessarily.<br>
To solve this, we can introduce an additional <strong>game state</strong>, which acts as a parent for both the play and pause states. This way, the shared modules, like the player avatar, can be handled by the parent, avoiding redundant toggling when transitioning between play and pause.</p>
<p>In essence, by nesting states, we can better manage common modules and eliminate unnecessary operations, resulting in a cleaner and more efficient system.
<img src="../../images/States2.png" alt="Game State"></p>
<p>Let’s make a few more assumptions to finalize our example:</p>
<ul>
<li>The game is very simple and runs on a single scene.</li>
<li>There is a main menu that covers the entire screen.</li>
</ul>
<p>Now, imagine launching the game. The first thing you see is the main menu. When you click the play button, the actual game starts. Then, you can pause the game and exit to the main menu. If you click the play button again, the game will start, but it won’t be paused.<br>
So, we should note that there is a default state at each nesting level, which is entered every time a parent state is entered.
<img src="../../images/States3.png" alt="Game State, Menu State and defaults"></p>
<h2 id="implementation">Implementation</h2>
<p>In this section, we will recreate the concept of stateful behavior from the introduction. To make it more complete, let's add one more state - the credits state. It should look like this:
<img src="../../images/States4.png" alt="All states"></p>
<h3 id="creating-a-state">Creating a State</h3>
<p>The core component of stateful behavior is the state itself. A state can be entered and exited, and to create one, you need to implement the <a class="xref" href="../../api/AlchemyBow.Core.States.IState.html">IState</a> interface.
For example, let's create the pause state:</p>
<pre><code>using AlchemyBow.Core.IoC;
using AlchemyBow.Core.States;

[InjectionTarget]
public class GamePauseState : IState
{
    [Inject] // Suppose such a module exists
    private readonly PauseMenuViewController pauseMenuViewController;
    [Inject] // Suppose such a module exists
    private readonly GameTimeController gameTimeController;

    public void Enter()
    {
        pauseMenuViewController.SetActive(true);
        gameTimeController.PauseTime();
    }

    public void Exit()
    {
        pauseMenuViewController.SetActive(false);
        gameTimeController.UnpauseTime();
    }
}
</code></pre>
<p>Since the <a class="xref" href="../../api/AlchemyBow.Core.States.IState.html">IState</a> is an interface, it can be implemented by any class — whether a plain C# class (like the example), or a class that inherits from <code>MonoBehaviour</code>, <code>ScriptableObject</code>, or any other Unity-specific class.<br>
In order for the state to have its fields injected, you must bind it, just like you would with any other class.</p>
<h3 id="creating-a-condition">Creating a Condition</h3>
<p>Similar to states, conditions are created by implementing the <a class="xref" href="../../api/AlchemyBow.Core.States.ICondition.html">ICondition</a> interface. There is no single &quot;perfect&quot; way to implement a condition. Depending on the situation, conditions can act as mediators between the state machine and other scripts, or they can function as fully independent entities. For example, they could be <code>MonoBehaviour</code> instances with an <code>Update()</code> method or other implementations based on your needs.</p>
<p>The important part to understand is how the state machine uses conditions:</p>
<ul>
<li>When a state is entered, all its conditions are activated, and the state machine subscribes to their <code>Triggered</code> events.</li>
<li>When the <code>Triggered</code> event is raised, the state machine checks the active state transitions with <code>ICondition.CheckCondition()</code> and starts the first transition that is fulfilled.</li>
<li>When a state is exited, all its conditions are deactivated, and the state machine unsubscribes from their <code>Triggered</code> events.</li>
</ul>
<p>Let’s now create the <code>PauseCondition</code>:</p>
<pre><code>using AlchemyBow.Core.States;

public class PauseCondition : ICondition
{
    public event System.Action Triggered;
    private bool conditionValue;

    // Sets the internal value and raises the event.
    public void Trigger()
    {
        conditionValue = true;
        Triggered?.Invoke();
    }

    // Resets the internal value.
    public void SetActive(bool value)
    {
        conditionValue = false;
    }

    public bool CheckCondition()
    {
        return conditionValue;
    }
}
</code></pre>
<p>The condition above acts like a trigger button. The <code>Trigger()</code> method raises the event, and the <code>SetActive(bool value)</code> method resets its internal state. You can bind it and then inject it wherever you need it, allowing you to call the <code>Trigger()</code> method as a consequence of clicking the &quot;Escape&quot; button.</p>
<p>The same effect as described above can also be achieved using the <a class="xref" href="../../api/AlchemyBow.Core.States.Prototyping.PrototypeCondition.html">PrototypeCondition</a>.</p>
<pre><code>using AlchemyBow.Core.States.Prototyping;

public class PauseCondition : PrototypeCondition 
{ 

}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>The condition can inherit from <code>MonoBehaviour</code> to receive Unity messages, or from <code>ScriptableObject</code> to be more convenient for editor drag-and-drop functionality.</p>
</div>
<h3 id="creating-a-state-machine">Creating a State Machine</h3>
<p>Now that we know how to create states and conditions, it's time to build the state machine itself. The framework provides a predefined hierarchical finite state machine implementation. Let's break down these terms:</p>
<ul>
<li><strong>Predefined</strong> means that all states, transitions, and conditions are created during initialization, allowing us to clearly plan and view the entire structure in one place.</li>
<li><strong>Hierarchical</strong> means that states can be nested.</li>
<li><strong>Finite</strong> means that there is a finite number of states.</li>
</ul>
<p>The state machine is represented by the <a class="xref" href="../../api/AlchemyBow.Core.States.StateGraph.html">StateGraph</a> class, which we build using the <a class="xref" href="../../api/AlchemyBow.Core.States.StateGraphComposer.html">StateGraphComposer</a> class, representing a single node (state).<br>
For now, let's assume that we have all the states and conditions set up (we’ll revisit these concepts in more detail later).</p>
<pre><code>private StateGraph CreateStateGraph()
{
    // Similar to the scenario where gameState is a parent of 
    // gamePlayState and gamePauseState, we need to create 
    // a parent for menuState, creditsState, and gameState.
    // Since they don't have any shared elements, we can create 
    // a simple root state with null.
    var rootComposer = new StateGraphComposer(null);

    // Create composers for each state.
    var menuComposer = new StateGraphComposer(menuState);
    var creditsComposer = new StateGraphComposer(creditsState);
    var gameComposer = new StateGraphComposer(gameState);
    var gamePlayComposer = new StateGraphComposer(gamePlayState);
    var gamePauseComposer = new StateGraphComposer(gamePauseState);

    // Mark gamePlayState and gamePauseState as children of gameState
    // and link them accordingly. 
    // The first child added is the default one!
    gameComposer.AddNode(gamePlayComposer); 
    gameComposer.AddNode(gamePauseComposer);
    gameComposer.AddLink(gamePlayComposer, gamePauseComposer, pauseCondition);
    gameComposer.AddLink(gamePauseComposer, gamePlayComposer, pauseCondition);

    // Mark menuState, creditsState, and gameState as children of the root
    // and link them accordingly. 
    // The first child added is the default one!
    rootComposer.AddNode(menuComposer);
    rootComposer.AddNode(creditsComposer);
    rootComposer.AddNode(gameComposer);
    rootComposer.AddLink(menuComposer, creditsComposer, creditsCondition);
    rootComposer.AddLink(creditsComposer, menuComposer, menuCondition);
    rootComposer.AddLink(menuComposer, gameComposer, gameCondition);
    rootComposer.AddLink(gameComposer, menuComposer, menuCondition);

    // Validate the graph, but only in the Unity editor.
#if UNITY_EDITOR
    rootComposer.Validate();
    string paths = &quot;Graph paths:\n&quot;;
    foreach (var path in rootComposer.GetGraphPaths())
    {
        paths += path + &quot;\n&quot;;
    }
    Debug.Log(paths); 
#endif

    // Build and return the actual StateGraph.
    return StateGraph.Build(rootComposer);
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>You can reuse conditions and states (see <code>pauseCondition</code> in the example). However, they cannot be active at the same time. The <code>StateGraphComposer.Validate()</code> method ensures the correct composition.</p>
</div>
<div class="TIP">
<h5>Tip</h5>
<p>The validation methods use the <code>ToString()</code> method to determine the names of the states (<a class="xref" href="../../api/AlchemyBow.Core.States.IState.html">IState</a>). You can override the <code>ToString()</code> method in your <a class="xref" href="../../api/AlchemyBow.Core.States.IState.html">IState</a> implementations for more readable output.</p>
</div>
<h3 id="connecting-the-state-machine">Connecting the State Machine</h3>
<p>Now, let's see how to connect the state machine to the framework. It's typically a good idea to delegate this task to a separate class for better organization, but for clarity, we'll implement it directly in the <a class="xref" href="../../api/AlchemyBow.Core.CoreController-1.html">CoreController</a>.</p>
<pre><code>using AlchemyBow.Core;
using AlchemyBow.Core.IoC;
using AlchemyBow.Core.States;
using System.Collections.Generic;
using UnityEngine;

public class MyCoreController : CoreController&lt;MyCoreProjectContext&gt;
{
    // Assuming that the state and condition classes are defined 
    // and work like the previous examples.
    private readonly MenuState menuState = new MenuState();
    private readonly CreditsState creditsState = new CreditsState();
    private readonly GameState gameState = new GameState();
    private readonly GamePlayState gamePlayState = new GamePlayState();
    private readonly GamePauseState gamePauseState = new GamePauseState();

    private readonly MenuCondition menuCondition = new MenuCondition();
    private readonly CreditsCondition creditsCondition = new CreditsCondition();
    private readonly GameCondition gameCondition = new GameCondition();
    private readonly PauseCondition pauseCondition = new PauseCondition();

    // The state machine.
    private StateGraph stateGraph;

    protected override void InstallAdditionalBindings(IBindOnlyContainer container)
    {
        // Bind the conditions to keys so that they can be injected as dependencies.
        container.Bind(menuCondition);
        container.Bind(creditsCondition);
        container.Bind(gameCondition);
        container.Bind(pauseCondition);

        // Bind the states (they need dependencies, but should not be accessible externally).
        container.BindInaccessible(menuState);
        container.BindInaccessible(creditsState);
        container.BindInaccessible(gameState);
        container.BindInaccessible(gamePlayState);
        container.BindInaccessible(gamePauseState);

        base.InstallAdditionalBindings(container);
    }

    protected override void OnLoadingFinished()
    {
        base.OnLoadingFinished();
        // Create and activate the state machine once loading is complete.
        stateGraph = CreateStateGraph();
        stateGraph.Enter(); 
    }

    protected override void OnSceneChangeStarted()
    {
        // Deactivate the state machine when unloading begins.
        stateGraph.Exit();
        base.OnSceneChangeStarted();
    }

    private StateGraph CreateStateGraph()
    {
        // ...
    }

    protected override IEnumerable&lt;ICoreLoadable&gt; GetLoadables()
    {
        return null;
    }
}
</code></pre>
<h2 id="remarks">Remarks</h2>
<p>In this section, you will find some interesting details on this topic.</p>
<h3 id="unity-messages-in-states">Unity Messages in States</h3>
<p>You may be wondering how to get Unity messages (<code>Update()</code>, <code>OnGUI()</code>, etc.) inside states. The most common options are:</p>
<ul>
<li>Delegating Unity-specific tasks to other classes and simply toggling their activity in the state. This keeps state classes focused on handling state transitions and avoids cluttering them with Unity-specific behavior.</li>
<li>States can inherit from the <code>MonoBehaviour</code> class if you need to directly handle Unity messages within them.</li>
<li>You can combine the <code>StateGraph.EnumerateDown(...)</code> method with interfaces to invoke a message in order from the parent to the leaf. For example:</li>
</ul>
<pre><code>public class MyCoreController : CoreController&lt;MyCoreProjectContext&gt;
{
    // ...
    private StateGraph stateGraph;
    // ...
    private void Update()
    {
        // Iterate through states and call Update if they implement IUpdatable
        stateGraph.EnumerateDown(state =&gt;
        {
            if (state is IUpdatable updatable)
            {
                updatable.Update();
            }
        }, true);
    }
}

// A custom interface for states that need to be updated.
public interface IUpdatable
{
    void Update();
}
</code></pre>
<h3 id="conditions-gotchas">Conditions Gotchas</h3>
<ul>
<li>If multiple conditions are true when the state is activated, the order in which the links were added determines which transition is triggered.</li>
<li>Raising the <code>ICondition.Triggered</code> event in the <code>ICondition.SetActive(bool value)</code> method does not affect the state machine. In case the state is activated, all conditions are checked when activation is complete. In case the state is deactivated, the event is completely ignored.</li>
</ul>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      <span>Copyright © 2022-2024 <a href="https://www.alchemybow.com/"><b>AlchemyBow</b></a></span> | <span>Generated by <b>DocFX</b></span>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
